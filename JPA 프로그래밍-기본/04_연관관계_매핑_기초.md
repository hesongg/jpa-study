### 자바 ORM 표준 JPA 프로그래밍 - 기본편

#### Reference) 
	* 자바 ORM 표준 JPA 프로그래밍 - 기본편 (인프런)

#### 작성 코드
- https://github.com/hesongg/JPA-Ex
	
<br>

### 연관관계 매핑 기초

- 목표
	- 객체와 테이블 연관관계의 차이를 이해
	- 객체의 참조와 테이블의 외래 키를 매핑
	- 용어 이해
		- 방향(Direction) : 단방향, 양방향
		
		- 다중성(Multiplicity) : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M) 이해
		
		- 연관관계의 주인(Owner) : 객체 양방향 연관관계는 관리 주인이 필요

<br>

#### 연관관계가 필요한 이유

- 객체를 테이블에 맞추어 모델링 (연관관계가 없는 객체)

	![image](https://user-images.githubusercontent.com/77953474/190112421-ccbb25c3-ef1c-40b7-a24f-3d5f59407de7.png)


<br>
	
- 객체를 테이블에 맞추어 모델링 (참조 대신에 외래 키를 그대로 사용)
	```java
	@Entity
	public class Member {
	
		@Id @GeneratedValue
		private Long id;
		
		@Column(name = "USERNAME")
		private String name;
		
		@Column(name = "TEAM_ID")
		private Long teamId;
		…
	}
	
	@Entity
	public class Team {
	
		@Id @GeneratedValue
		private Long id;
		
		private String name;
		…
	}
	```

<br>

- 객체를 테이블에 맞추어 모델링 (외래 키 식별자를 직접 다룸)
	```java
	//팀 저장
	Team team = new Team();
	team.setName("TeamA");
	em.persist(team);
	
	//회원 저장
	Member member = new Member();
	member.setName("member1");
	member.setTeamId(team.getId());
	em.persist(member);
	```

<br>

- 객체를 테이블에 맞추어 모델링 (식별자로 다시 조회, 객체 지향적인 방법은 아니다.
	```java
	//조회
	Member findMember = em.find(Member.class, member.getId());
	
	//연관관계가 없음
	Team findTeam = em.find(Team.class, team.getId());
	```

<br>

- 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
	- 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다.
	- 객체는 참조를 사용해서 연관된 객체를 찾는다.
	- 테이블과 객체 사이에는 이런 큰 간격이 있다.

<br>

#### 단방향 연관관계

- 객체 지향 모델링 (객체 연관관계 사용)

	![image](https://user-images.githubusercontent.com/77953474/190112483-80124cd3-6df8-4198-aa5a-d29cbc0667e4.png)


<br>

- 객체 지향 모델링 (객체의 참조와 테이블의 외래 키를 매핑)
	
	```java
	@Entity
	public class Member {
		@Id @GeneratedValue
		private Long id;
		
		@Column(name = "USERNAME")
		private String name;
		
		private int age;
		
		// @Column(name = "TEAM_ID")
		
		// private Long teamId;
		
		@ManyToOne
		@JoinColumn(name = "TEAM_ID")
		private Team team;
		… 
	```

<br>

- 객체 지향 모델링 (ORM 매핑)

	![image](https://user-images.githubusercontent.com/77953474/190112544-1e8ab5c7-dcc7-4fb4-8ed1-4d4c5309815b.png)


<br>

- 객체 지향 모델링 (연관관계 저장)
	
	```java
	//팀 저장
	Team team = new Team();
	team.setName("TeamA");
	em.persist(team);
	
	//회원 저장
	Member member = new Member();
	member.setName("member1");
	member.setTeam(team); //단방향 연관관계 설정, 참조 저장
	em.persist(member);
	```
<br>

- 객체 지향 모델링 (참조로 연관관계 조회 - 객체 그래프 탐색)
	
	```java
	//조회
	Member findMember = em.find(Member.class, member.getId());
	
	//참조를 사용해서 연관관계 조회
	Team findTeam = findMember.getTeam();
	```
<br>

- 객체 지향 모델링 (연관관계 수정)
	
	```java
	// 새로운 팀B
	Team teamB = new Team();
	teamB.setName("TeamB");
	em.persist(teamB);
	
	// 회원1에 새로운 팀B 설정
	member.setTeam(teamB);
	```

<br>

#### 양방향 연관관계와 연관관계의 주인

- 양방향 매핑
	![image](https://user-images.githubusercontent.com/77953474/190112620-9d0c901a-fc8c-4cd9-9817-810f05ce38cb.png)

	
	- 객체와 테이블의 양방향 매핑 차이
		- 테이블은 외래키 하나만 넣어주면 양쪽으로 다 조회 가능
		- 객체의 경우 각 객체 별로 따로 가지고 있어야 함

<br>

- 양방향 매핑 (```Member``` 엔티티는 단방향과 동일)
	
	```java
	@Entity
	public class Member {
	 
		@Id @GeneratedValue
		private Long id;

		@Column(name = "USERNAME")
		private String name;
		private int age;

		@ManyToOne
		@JoinColumn(name = "TEAM_ID")
		private Team team;
	… 
	```

<br>

- 양방향 매핑 (```Team``` 엔티티는 컬렉션 추가)
	
	```java
	@Entity
	public class Team {
		@Id @GeneratedValue
		private Long id;
		private String name;
		
		@OneToMany(mappedBy = "team")
		List<Member> members = new ArrayList<Member>();
		…
	}
	```
	
<br>

- 양방향 매핑 (반대 방향으로 객체 그래프 탐색)
	```java
	//조회
	Team findTeam = em.find(Team.class, team.getId());
	
	int memberSize = findTeam.getMembers().size(); //역방향 조회
	```
	
<br>

- 연관관계의 주인과 ```mappedBy```
	- mappedBy = JPA의 멘탈붕괴 난이도
	- mappedBy는 처음에는 이해하기 어렵다.
	- 객체와 테이블간에 연관관계를 맺는 차이를 이해해야 한다.

<br>

- 객체와 테이블이 관계를 맺는 차이
	- 객체 연관관계 = 2개
		- 회원 -> 팀 연관관계 1개(단방향)
		- 팀 -> 회원 연관관계 1개(단방향)
		
		- 각 객체 별로 필요한 서로 다른 참조 값을 가지고 있다.
			- 단반향 연관관계가 2개가 있다고 볼 수 있다.
	
	- 테이블 연관관계 = 1개
		- 회원 <-> 팀의 연관관계 1개(양방향)
		
		- 외래키 하나로 양쪽의 연관관계를 파악할 수 있다.
<br>

- 객체와 테이블이 관계를 맺는 차이
	![image](https://user-images.githubusercontent.com/77953474/190112699-81d0730d-5b12-4daf-9087-444a1617af85.png)


<br>

- 객체의 양방향 관계
	- 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단 뱡향 관계 2개다.
	
	- 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다. 
		- ```A -> B (a.getB())```
		- ```B -> A (b.getA())```
		
<br>

- 테이블의 양방향 연관관계
	- 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리
	- ```MEMBER.TEAM_ID``` 외래 키 하나로 양방향 연관관계 가짐 (양쪽으로 조인할 수 있다.)
	
	```sql
	SELECT *
	FROM MEMBER M
	JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
	
	SELECT *
	FROM TEAM T
	JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
	```
	
<br>

- 둘 중 하나로 외래 키를 관리해야 한다.
	
	![image](https://user-images.githubusercontent.com/77953474/190112796-04905cb1-4ce5-436f-a4cb-6844faae46be.png)


<br>

- 연관관계의 주인(Owner)
	
	- 양방향 매핑 규칙
		- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
		- 연관관계의 주인만이 외래 키를 관리(등록, 수정)
		- 주인이 아닌쪽은 읽기만 가능
		- 주인은 ```mappedBy``` 속성 사용X
		- 주인이 아니면 ```mappedBy``` 속성으로 주인 지정

<br>

- 누구를 주인으로?
	- 외래 키가 있는 있는 곳을 주인으로 정해라
		- ```@ManyToOne``` 을 사용하는 쪽, N:1 인 경우 DB 입장에서 N쪽이 연관관계의 주인이 되면 된다.
		- 쿼리 수행이 직관적이다. 
			- ex) 외래 키를 가지고 있는 주인 객체를 수정한 경우, 해당 객체에 대한 update 쿼리가 나가게 된다.
			- 만약 N:1 에서 1을 연관관계의 주인을 설정한 경우(위 예시와 반대로),
				1쪽 객체를 수정했는데 N쪽 객체에 관련된 업데이트 쿼리가 나가게 되므로 직관적이지 않다.
		
	- 여기서는 ```Member.team```이 연관관계의 주인
		
		![image](https://user-images.githubusercontent.com/77953474/190112881-0fb163da-c118-4830-9746-0e64f81ddb58.png)


<br>

- 양방향 매핑시 가장 많이 하는 실수 (연관관계의 주인에 값을 입력하지 않음)
	```java
	Team team = new Team();
	team.setName("TeamA");
	em.persist(team);
	
	Member member = new Member();
	member.setName("member1");
	
	//역방향(주인이 아닌 방향)만 연관관계 설정
	team.getMembers().add(member);
	
	em.persist(member);
	```
	
	![image](https://user-images.githubusercontent.com/77953474/190112927-60eca5fd-6a35-4d40-9f24-a6c8a441f458.png)


<br>

- 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다. (순수한 객체 관계를 고려하면 항상 양쪽다 값을 입력해야 한다.)
	
	```java
	Team team = new Team();
	team.setName("TeamA");
	em.persist(team);
	
	Member member = new Member();
	member.setName("member1");
	
	team.getMembers().add(member); // 순수 객체 상태를 고려해서 이 부분도 추가해야 함
	
	//연관관계의 주인에 값 설정
	member.setTeam(team);
	
	em.persist(member);
	```
	
	![image](https://user-images.githubusercontent.com/77953474/190113035-30989363-1c95-4ffa-a0f0-7b5aa59fed62.png)

	
	- 양방향 연관 관계의 경우 양쪽에 다 값을 세팅해야한다.
		- 위 코드에서 연관관계의 주인인 ```member```에만 ```team``` 값을 세팅해도 DB에 정상적으로 insert는 되지만,
			```team.getMembers().add(member);``` 이 부분을 추가해주지 않는다면
			```team``` 객체는 추가한 ```member``` 값을 가지지 못하기 때문에 결국 양쪽에 다 값을 세팅해주어야 한다.

<br>

- 양방향 연관관계 주의 - 실습
	- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
	
	- 연관관계 편의 메소드를 생성하자
		
		- ex) 밑의 두 방법 중 하나를 선택하여 사용 가능
			- ```Member``` 클래스에 ```changeTeam``` 메서드 생성
			
				```java
				public void changeTeam(Team team) {
					this.team = team;
					team.getMembers().add(this);
				}
				```
			
			- 또는 ```Team``` 클래스에 ```addMember``` 메서드 생성
				```java
				public void addMember(Member member) {
					member.setTeam(this);
					members.add(member);
				}
				```
			
			
		
	- 양방향 매핑시에 무한 루프를 조심하자
		- 예: ```toString()```, ```lombok```, JSON 생성 라이브러리
			- lombok에서 ```@toString```은 웬만하면 쓰지 말자
			- ```Controller``` 에서 Entity를 반환하지 말자.
				- json 변환으로 인한 무한루프 문제도 있지만 entity를 반환하는 것 자체가 좋지않다.
				- entity를 반환하면, entity를 수정하는 것으로 api의 명세서가 변경되기 때문
					- dto를 만들어서 그걸로 반환하자.

<br>

- 양방향 매핑 정리
	- 단방향 매핑만으로도 이미 연관관계 매핑은 완료
	
	- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
	
	- JPQL에서 역방향으로 탐색할 일이 많음
	
	- 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨 (테이블에 영향을 주지 않음)

<br>

- 연관관계의 주인을 정하는 기준
	- 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
	- 연관관계의 주인은 외래 키의 위치를 기준으로 정해야함

<br>

#### 실전 예제 - 2. 연관관계 매핑 시작

- 테이블 구조

	- 테이블 구조는 이전과 같다
	
	![image](https://user-images.githubusercontent.com/77953474/190113179-48ea98f8-5c19-4aff-97ed-037007eb548f.png)

	
	- 하나의 orders 가 여러 item을 주문 할 수 있기 때문에
		이런 1:N 관계를 풀어낸 1:N, N:1 order_item 이라는 테이블이 있음

<br>

- 객체 구조
	- 참조를 사용하도록 변경
	
	![image](https://user-images.githubusercontent.com/77953474/190113228-71b65835-878b-4a6b-9ce5-867fef94106a.png)

	
<br>

- 비지니스를 잘 확인해보고 꼭 필요한 경우만 양방향 연관관계 매핑을 사용하자.
	- ex) member <-> order (1:N) 의 경우, member 객체를 보고 orders를 조회하는 경우는 거의 없다.
		- 이런 경우는 굳이 양방향 연관관계를 맺지않아도 될듯
