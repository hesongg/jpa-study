### 실전! 스프링 부트와 JPA 활용2 - API 개발과 성능 최적화

#### Reference) 
	* 실전! 스프링 부트와 JPA 활용2 - API 개발과 성능 최적화 (인프런)

#### 작성 코드
- https://github.com/hesongg/SpringBoot-JPA-Practice

<br>

### API 개발 고급 - 컬렉션 조회 최적화

- 주문내역에서 추가로 주문한 상품 정보를 추가로 조회하자.
	- Order 기준으로 컬렉션인 ```OrderItem``` 와 ```Item``` 이 필요하다.
	
- 앞의 예제에서는 toOne(OneToOne, ManyToOne) 관계만 있었다. 
	
- 이번에는 컬렉션인 일대다 관계 (OneToMany)를 조회하고, 최적화하는 방법을 알아보자.

<br>

#### 주문 조회 V1: 엔티티 직접 노출

- ```OrderApiController``` - ```ordersV1``` 메서드 추가
	- ```orderItem``` , ```item``` 관계를 직접 초기화하면 ```Hibernate5Module``` 설정에 의해 엔티티를 JSON으로 생성한다.
	- 양방향 연관관계면 무한 루프에 걸리지 않게 한곳에 ```@JsonIgnore``` 를 추가해야 한다.
	- 엔티티를 직접 노출하므로 좋은 방법은 아니다.

<br>

#### 주문 조회 V2: 엔티티를 DTO로 변환

- ```OrderApiController``` - ```ordersV2``` 메서드 추가

- 지연 로딩으로 너무 많은 SQL 실행

- SQL 실행 수
	- ```order``` 1번
	- ```member``` , ```address``` N번(order 조회 수 만큼)
	- ```orderItem``` N번(order 조회 수 만큼)
		- ```item``` N번(orderItem 조회 수 만큼)
	
	- 참고
		- 지연 로딩은 영속성 컨텍스트에 있으면 영속성 컨텍스트에 있는 엔티티를 사용하고 없으면 SQL을 실행한다. 
		
		- 따라서 같은 영속성 컨텍스트에서 이미 로딩한 회원 엔티티를 추가로 조회하면 SQL을 실행하지 않는다

<br>

#### 주문 조회 V3: 엔티티를 DTO로 변환 - 페치 조인 최적화

- ```OrderApiController```에 추가 - ```ordersV3``` 메서드 추가

	- 페치 조인으로 SQL이 1번만 실행됨

	- ```distinct``` 를 사용한 이유는 1대다 조인이 있으므로 데이터베이스 row가 증가한다. 
		- 그 결과 같은 ```order``` 엔티티의 조회 수도 증가하게 된다. 
		
		- JPA의 distinct는 SQL에 distinct를 추가하고, 더해서 같은 엔티티가 조회되면, 애플리케이션에서 중복을 걸러준다. 
		
		- 이 예에서 ```order```가 컬렉션 페치 조인 때문에 중복 조회 되는 것을 막아준다.

	- 단점
		- 페이징 불가능

<br>

- 참고
	- 컬렉션 페치 조인을 사용하면 페이징이 불가능하다. 하이버네이트는 경고 로그를 남기면서 모든 데이터를 DB에서 읽어오고, 
		메모리에서 페이징 해버린다(매우 위험하다). 

	- 자세한 내용은 자바 ORM 표준 JPA 프로그래밍의 페치 조인 부분을 참고

<br>

- 참고
	- 컬렉션 페치 조인은 1개만 사용할 수 있다. 
	- 컬렉션 둘 이상에 페치 조인을 사용하면 안된다. 데이터가 부정합하게 조회될 수 있다. 
	- 자세한 내용은 자바 ORM 표준 JPA 프로그래밍을 참고

<br>

#### 주문 조회 V3.1: 엔티티를 DTO로 변환 - 페이징과 한계 돌파

- 페이징과 한계 돌파

	- 컬렉션을 페치 조인하면 페이징이 불가능하다.
		- 컬렉션을 페치 조인하면 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가한다.
		- 일다대에서 일(1)을 기준으로 페이징을 하는 것이 목적이다. 그런데 데이터는 다(N)를 기준으로 row	가 생성된다.
		- Order를 기준으로 페이징 하고 싶은데, 다(N)인 OrderItem을 조인하면 OrderItem이 기준이	되어버린다.
		- (더 자세한 내용은 자바 ORM 표준 JPA 프로그래밍 - 페치 조인 한계 참조)
	
	- 이 경우 하이버네이트는 경고 로그를 남기고 모든 DB 데이터를 읽어서 메모리에서 페이징을 시도한다.
		- 최악의 경우 장애로 이어질 수 있다.

<br>

- 한계 돌파
	- 그러면 페이징 + 컬렉션 엔티티를 함께 조회하려면 어떻게 해야할까?
	- 지금부터 코드도 단순하고, 성능 최적화도 보장하는 매우 강력한 방법을 소개하겠다. 
	- 대부분의 페이징 +	컬렉션 엔티티 조회 문제는 이 방법으로 해결 가능
	
	<br>
	
	- 먼저 ToOne(OneToOne, ManyToOne) 관계를 모두 페치조인 한다. 
		- ToOne 관계는 row수를 증가시키지 않으므로 페이징 쿼리에 영향을 주지 않는다.
		
	- 컬렉션은 지연 로딩으로 조회한다.
	
	- 지연 로딩 성능 최적화를 위해 ```hibernate.default_batch_fetch_size``` , ```@BatchSize``` 를 적용한다.
		- ```hibernate.default_batch_fetch_size``` : 글로벌 설정
		- ```@BatchSize``` : 개별 최적화
		- 이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회한다

<br>

- ```OrderRepository```에 추가 - ```findAllWithMemberDelivery(int offset, int limit)```

- ```OrderApiController```에 추가 - ```ordersV3_page``` 메서드

<br>

- 최적화 옵션 적용
	```yml
	spring:
		jpa:
			properties:
				hibernate:
					default_batch_fetch_size: 1000
	```
	
	- 개별로 설정하려면 ```@BatchSize``` 를 적용하면 된다. 
		- (컬렉션은 컬렉션 필드에, 엔티티는 엔티티 클래스에 적용)
	
	<br>

	- 장점
		- 쿼리 호출 수가 ```1 + N``` -> ```1 + 1``` 로 최적화 된다.
		
		- 조인보다 DB 데이터 전송량이 최적화 된다. (Order와 OrderItem을 조인하면 Order가
			OrderItem 만큼 중복해서 조회된다. 이 방법은 각각 조회하므로 전송해야할 중복 데이터가 없다.)
		
		- 페치 조인 방식과 비교해서 쿼리 호출 수가 약간 증가하지만, DB 데이터 전송량이 감소한다.
		
		- 컬렉션 페치 조인은 페이징이 불가능 하지만 이 방법은 페이징이 가능하다.
	
	- 결론
		- ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않는다. 따라서 ToOne 관계는 페치조인으로 쿼리 수를 줄이고 해결하고,
			나머지는 ```hibernate.default_batch_fetch_size``` 로 최적화 하자.

<br>

- 참고
	- ```default_batch_fetch_size``` 의 크기는 적당한 사이즈를 골라야 하는데, 
		100~1000 사이를 선택하는 것을 권장
	
	- 이 전략을 SQL IN 절을 사용하는데, 데이터베이스에 따라 IN 절 파라미터를 1000으로 제한하기도 한다. 
	
	- 1000으로 잡으면 한번에 1000개를 DB에서 애플리케이션에 불러오므로 DB 에 순간 부하가 증가할 수 있다. 
	
	- 하지만 애플리케이션은 100이든 1000이든 결국 전체 데이터를 로딩해야 하므로 메모리 사용량이 같다. 
	
	- 1000으로 설정하는 것이 성능상 가장 좋지만, 결국 DB든 애플리케이션이든 순간 부하를 어디까지 견딜 수 있는지로 결정하면 된다.

<br>

#### 주문 조회 V4: JPA에서 DTO 직접 조회 

- 컬렉션이 있을 때 JPA에서 DTO 직접 조회 

- ```OrderApiController``` 에 추가 - ```ordersV4``` 메서드

	- Query : 루트 1번, 컬렉션 N 번 실행

	- ToOne(N:1, 1:1) 관계들을 먼저 조회하고, ToMany(1:N) 관계는 각각 별도로 처리한다.
		- 이런 방식을 선택한 이유는 다음과 같다.
		- ToOne 관계는 조인해도 데이터 row 수가 증가하지 않는다.
		- ToMany(1:N) 관계는 조인하면 row 수가 증가한다.

	- row 수가 증가하지 않는 ToOne 관계는 조인으로 최적화 하기 쉬우므로 한번에 조회하고, 
		ToMany 관계는 최적화 하기 어려우므로 ```findOrderItems()``` 같은 별도의 메서드로 조회한다.

<br>

#### 주문 조회 V5: JPA에서 DTO 직접 조회 - 컬렉션 조회 최적화

- ```OrderApiController```에 추가 - ```ordersV5``` 메서드
	- Query : 루트 1번, 컬렉션 1번
	- ToOne 관계들을 먼저 조회하고, 여기서 얻은 식별자 ```orderId``` 로 ToMany 관계인 ```OrderItem``` 을 한꺼번에 조회
	- MAP을 사용해서 매칭 성능 향상(O(1))

<br>

#### 주문 조회 V6: JPA에서 DTO로 직접 조회, 플랫 데이터 최적화

- ```OrderApiController```에 추가 - ```ordersV6``` 메서드
	- Query: 1번
	- 단점
		- 쿼리는 한번이지만 조인으로 인해 DB에서 애플리케이션에 전달하는 데이터에 중복 데이터가	추가되므로 
			상황에 따라 V5 보다 더 느릴 수 도 있다.
		
		- 애플리케이션에서 추가 작업이 크다.
		
		- 페이징 불가능

<br>

#### API 개발 고급 정리

- 정리

	- 엔티티 조회
		- 엔티티를 조회해서 그대로 반환: V1
		
		- 엔티티 조회 후 DTO로 변환: V2
		
		- 페치 조인으로 쿼리 수 최적화: V3
		
		- 컬렉션 페이징과 한계 돌파: V3.1
			- 컬렉션은 페치 조인시 페이징이 불가능
			- ToOne 관계는 페치 조인으로 쿼리 수 최적화
			- 컬렉션은 페치 조인 대신에 지연 로딩을 유지하고, ```hibernate.default_batch_fetch_size``` , 
				```@BatchSize``` 로 최적화
	
	<br>
	
	- DTO 직접 조회
		- JPA에서 DTO를 직접 조회: V4
		
		- 컬렉션 조회 최적화 - 일대다 관계인 컬렉션은 IN 절을 활용해서 메모리에 미리 조회해서 최적화: V5
		
		- 플랫 데이터 최적화 - JOIN 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환: V6

<br>

- 권장 순서
	- 1. 엔티티 조회 방식으로 우선 접근
		- 1. 페치조인으로 쿼리 수를 최적화
		
		- 2. 컬렉션 최적화
			- 1. 페이징 필요 hibernate.default_batch_fetch_size , @BatchSize 로 최적화
			- 2. 페이징 필요X 페치 조인 사용
	
	- 2. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
	
	- 3. DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate

<br>

- 참고
	- 엔티티 조회 방식은 페치 조인이나, ```hibernate.default_batch_fetch_size``` , ```@BatchSize``` 같이
		코드를 거의 수정하지 않고, 옵션만 약간 변경해서, 다양한 성능 최적화를 시도할 수 있다. 
	
	- 반면에 DTO를 직접 조회하는 방식은 성능을 최적화 하거나 성능 최적화 방식을 변경할 때 많은 코드를 변경해야 한다.

<br>

- 참고
	- 개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야 한다. 
	
	- 항상 그런 것은 아니지만, 보통 성능 최적화는 단순한 코드를 복잡한 코드로 몰고간다.
	
	- 엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에, 단순한 코드를 유지하면서, 성능을 최적화 할 수 있다.
	
	- 반면에 DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에, 둘 사이에 줄타기를 해야 한다.

<br>

- DTO 조회 방식의 선택지
	- DTO로 조회하는 방법도 각각 장단이 있다. V4, V5, V6에서 단순하게 쿼리가 1번 실행된다고 V6이 항상 좋은 방법인 것은 아니다.
	
	- V4는 코드가 단순하다. 특정 주문 한건만 조회하면 이 방식을 사용해도 성능이 잘 나온다. 
		- 예를 들어서 조회한 Order 데이터가 1건이면 OrderItem을 찾기 위한 쿼리도 1번만 실행하면 된다.
		
	- V5는 코드가 복잡하다. 여러 주문을 한꺼번에 조회하는 경우에는 V4 대신에 이것을 최적화한 V5 방식을	사용해야 한다. 
		- 예를 들어서 조회한 Order 데이터가 1000건인데, V4 방식을 그대로 사용하면, 쿼리가 총 1 + 1000번 실행된다. 
		- 여기서 1은 Order 를 조회한 쿼리고, 1000은 조회된 Order의 row 수다. 
		- V5 방식으로 최적화 하면 쿼리가 총 1 + 1번만 실행된다. 
		- 상황에 따라 다르겠지만 운영 환경에서 100배 이상의 성능 차이가 날 수 있다.
	
	- V6는 완전히 다른 접근방식이다. 
		- 쿼리 한번으로 최적화 되어서 상당히 좋아보이지만, Order를 기준으로	페이징이 불가능하다. 
		- 실무에서는 이정도 데이터면 수백이나, 수천건 단위로 페이징 처리가 꼭 필요하므로, 이 경우 선택하기 어려운 방법이다. 
		- 그리고 데이터가 많으면 중복 전송이 증가해서 V5와 비교해서 성능 차이도 미비하다
